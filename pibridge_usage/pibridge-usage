#!/usr/bin/env python3
import signal
from argparse import ArgumentParser
from multiprocessing import Event, Process, Queue
from queue import Empty
from sys import stdout, stderr
from timeit import default_timer

QUEUE_WRITE_TIMEOUT = 0.2
__version__ = "2025.10.29"

pargs = ArgumentParser()
pargs.add_argument("--version", action="version", version=__version__)
pargs.add_argument(
    "-b",
    "--bytes",
    type=int,
    default=512,
    help="Number of bytes to read/write per cycle (default: 512)",
)
pargs.add_argument(
    "-t",
    "--runtime-sec",
    type=int,
    default=60,
    help="Number of seconds to run the test (default: 60)",
)
pargs.add_argument(
    "-w",
    "--write",
    action="store_true",
    default=False,
    help="Read/write bytes instead of just reading",
)
pargs.add_argument(
    "-m",
    "--max-milliseconds",
    type=int,
    default=5,
    help="Maximum number of milliseconds to wait for a single read/write operation (default: 5)",
)
pargs.add_argument(
    "-p",
    "--processes",
    type=int,
    default=1,
    help="Number of processes to run in parallel (default: 1)",
)
pargs.add_argument(
    "-v",
    "--verbose",
    action="store_true",
    default=False,
)
args = pargs.parse_args()


class TestProcess(Process):
    def __init__(self, exit_event: Event, queue_cycles: Queue, queue_runtime_fails: Queue):
        super().__init__()
        self.exit_event = exit_event
        self.q_cycles = queue_cycles
        self.q_runtime_fails = queue_runtime_fails

    def run(self):
        cycles = 0
        proc_img = open("/dev/piControl0", "r+b", buffering=0)
        start_time = default_timer()

        while default_timer() - start_time < args.runtime_sec and not self.exit_event.is_set():
            ot = default_timer()

            # Read bytes
            proc_img.seek(0)
            buffer = proc_img.read(args.bytes)

            if args.write:
                # Write bytes
                proc_img.seek(0)
                proc_img.write(buffer)

            diff = default_timer() - ot
            if diff > max_milliseconds:
                self.q_runtime_fails.put_nowait(diff)

            cycles += 1

        proc_img.close()
        self.q_cycles.put_nowait(cycles)


evt_exit = Event()
max_milliseconds = args.max_milliseconds / 1000
lst_processes = []
q_cycles = Queue()
q_runtime_fails = Queue()
runtime_fails = []

# Attach signals
signal.signal(signal.SIGINT, lambda num, frame: evt_exit.set())
signal.signal(signal.SIGTERM, lambda num, frame: evt_exit.set())

# Start testing
stdout.write(f"Starting a {args.runtime_sec} seconds test with the following parameters.\n")
stdout.write(f"\tBytes: {args.bytes}\n")
stdout.write(f"\tRead/Write: {args.write}\n")
stdout.write(f"\tMax milliseconds: {args.max_milliseconds}\n")
stdout.write(f"\tProcesses: {args.processes}\n")

# Create processes and start them
for _ in range(args.processes):
    lst_processes.append(TestProcess(evt_exit, q_cycles, q_runtime_fails))
for process in lst_processes:
    process.start()

# Read the queue of the processes and print outputs
while any(multi_proc.is_alive() for multi_proc in lst_processes):
    try:
        fail = q_runtime_fails.get(timeout=QUEUE_WRITE_TIMEOUT)
        runtime_fails.append(fail)

        fail = round(fail * 1000, 1)
        stdout.write(f"\r{len(runtime_fails)} failures till now. Last failure: {fail:5.1f} ms")
    except Empty:
        if evt_exit.is_set():
            break

stdout.write("\r")

cycle_sum = 0
while not q_cycles.empty():
    cycle_sum += q_cycles.get()

if runtime_fails:
    stderr.write(
        f"During {args.runtime_sec} seconds we had {cycle_sum} cycles "
        f"and {len(runtime_fails)} with more than {args.max_milliseconds} ms.\n"
    )
    if args.verbose:
        for fail in runtime_fails:
            fail = round(fail * 1000, 1)
            stderr.write(f"\t{fail} ms\n")
    exit(1)
else:
    stdout.write("No runtime failures.\n")
    exit(0)
